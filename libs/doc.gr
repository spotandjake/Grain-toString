/*
 * This file is a rather direct port of the Grain compiler's document formatting module:
 * https://github.com/grain-lang/grain/blob/main/compiler/src/formatting/doc.re
 *
 * Original work: Copyright (C) 2017-2024 Philip Blair, Oscar Spencer, & contributors
 * Modifications by Spotandjake (2025)
 *
 * This file is part of a program licensed under the GNU General Public License v3.0 or later.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program.
 * If not, see <https://www.gnu.org/licenses/>.
 */

/**
  The Doc module implements a document IR and engine for pretty-printing code.
  Concatenation of Doc.t nodes is O(1) and printing a document is O(n) to the
  size of the document.

  The most important aspect of the engine are groups and how breaks interact
  with them. By default, the engine will print a group by either breaking none
  of the break hints in that group if the entire group would fit on that line
  (known as Flat mode) or all of the break hints in that group if the group
  would not fit if printed in Flat mode (known as Breaking mode). This covers
  95% of formatting use cases, and users should tend to reach for default
  groups before considering one of the alternatives. For the remaining 5% of
  use cases, groups can also be created in FitGroups mode or FitAll mode. In
  FitGroups mode, the engine will attempt to print as many subgroups in Flat
  mode as possible on each line, breaking only when necessary. In FitAll mode,
  the engine will attempt to print as many subgroups in Breaking mode as
  possible on each line.

  Hardlines should be avoided. Instead, emit break hints and allow the engine
  to decide when breaks should be made. If hardlines must be used, consider
  using the group's ~print_width parameter to manually specify how wide the
  engine should consider the group. By default, a group is only considered as
  wide as the content leading to the first hardline.

  That's most of what you need to know to effectively use this module! Further
  details on each node are provided below for maintainers or curious consumers.

  IR nodes:
    • Empty
      Has no effect on the output of the printing engine.
    • GroupBreaker
      Causes the enclosing group to be printed in Breaking mode.
    • String
      Prints the string as-is. The `string` function is Utf8-aware.
    • Blank
      Prints the specified number of spaces.
    • BreakHint
      Tells the engine that a break can be made here. If the engine decides not
      to print a break, it prints the supplied document instead.
    • Hardline
      Forces the engine to print a newline character. Width calculations for
      the current line are truncated at the Hardline. If the `phantom` field is
      set to `true`, instead the Hardline is calculated as a zero-width non-
      breaking character (the newline is emitted in the output, but
      calculations assume it's just not there).
    • IfBroken
      If the engine has broken the current group, prints the `breaking`
      document and prints the `flat` document otherwise. Note that for FitAll
      and FitGroups groups, the `flat` document would be printed if the
      IfBroken node appears before the point at which the group is broken, as
      the engine makes that decision while printing the group (unlike default
      groups, where the engine makes this decision before printing the group).
    • Indent
      Introduces indentation equal to the number of spaces specified when the
      enclosing group is broken. When newline characters are emitted, they are
      followed by space characters equal to the amount of indentation that has
      been applied by all groups, unless this would lead to trailing
      whitespace. Note that if the enclosing group has not been broken, the
      indentation will not apply. For example, in this document,
        group(~kind=FitGroups, indent(2,
          group(indent(2, string("foo") ++ break ++ string("bar")))
        ))
      if the break hint is broken by the engine, `bar`'s indentation level will
      only be two spaces, as the outer group could never be broken be broken by
      the engine.
    • Group
      ~kind=Auto
        The engine checks if the group would fit on the current line if printed
        in Flat mode. If so, it prints the group in Flat mode and Breaking mode
        otherwise.
      ~kind=FitGroups
        The engine begins printing the group. When it encounters a break hint,
        it checks if the following node would fit on the current line. If that
        node is a Group, its Flat mode width is used for the check. If the node
        would not fit, a break is emitted.
      ~kind=FitAll
        The engine begins printing the group. When it encounters a break hint,
        it checks if the following node would fit on the current line. If that
        node is a Group, its Breaking mode width is used for the check. If the
        node would not fit, a break is emitted.
    • Concat
      Prints the first document followed by the second document. Keeps track of
      the combined width to allow the engine to make constant-time decisions
      about line breaks.
*/
@noPervasives
module Doc

from "runtime/unsafe/wasmI32" include WasmI32
from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/offsets" include Offsets
use Offsets.{ _STR_LEN_OFFSET, _STR_DATA_OFFSET }
from "runtime/dataStructures" include DataStructures
use DataStructures.{ allocateString, tagSimpleNumber, untagSimpleNumber }
from "runtime/utf8" include Utf8
use Utf8.{ isLeadingByte }

from "./miniBuffer.gr" include MiniBuffer

// Offsets

primitive (||) = "@or"
primitive throw = "@throw"
primitive ignore = "@ignore"

exception Impossible(String)

@unsafe
let (+) = (a: Number, b: Number) => {
  use WasmI32.{ (+) }
  tagSimpleNumber(untagSimpleNumber(a) + untagSimpleNumber(b))
}

@unsafe
let (>) = (a: Number, b: Number) => {
  use WasmI32.{ (>) }
  untagSimpleNumber(a) > untagSimpleNumber(b)
}

@unsafe
let stringLength = (string: String) => {
  use WasmI32.{ (+), (&), (!=), ltU as (<) }
  let mut stringPtr = WasmI32.fromGrain(string)
  let size = WasmI32.load(stringPtr, _STR_LEN_OFFSET)

  let mut len = 0n
  stringPtr += _STR_DATA_OFFSET
  let end = stringPtr + size

  while (stringPtr < end) {
    let byte = WasmI32.load8U(stringPtr, 0n)
    if (isLeadingByte(byte)) len += 1n
    stringPtr += 1n
  }
  ignore(string)
  tagSimpleNumber(len)
}
@unsafe
let buildSpaceString = count => {
  use WasmI32.{ (*), (+) }
  let size = untagSimpleNumber(count)
  let ptr = allocateString(size)
  // 32n is ASCII code for space
  Memory.fill(ptr + _STR_DATA_OFFSET, 32n, size)
  WasmI32.toGrain(ptr): String
}

/**
 * End-of-line styles for the printing engine.
 */
provide enum EOL {
  /** Carriage return + line feed */
  CRLF,
  /** Line feed */
  LF,
}

/**
 * The document IR used for printing.
 */
abstract enum rec LayoutNode {
  Empty,
  GroupBreaker,
  String{ value: String, width: Width },
  Blank{ count: Number, },
  BreakHint{ doc: LayoutNode, flatWidth: Width },
  Hardline{ phantom: Bool, },
  IfBroken{
    flat: LayoutNode,
    breaking: LayoutNode,
    flatWidth: Width,
    breakingWidth: Width,
  },
  Indent{
    count: Number,
    doc: LayoutNode,
    hasGroupBreaker: Bool,
    flatWidth: Width,
    breakingWidth: Width,
  },
  Group{
    groupType: GroupType,
    doc: LayoutNode,
    flatWidth: Width,
    breakingWidth: Width,
  },
  Concat{
    left: LayoutNode,
    right: LayoutNode,
    hasGroupBreaker: Bool,
    flatWidth: Width,
    breakingWidth: Width,
  },
}
/**
 * The type of group to create.
 */
and provide enum GroupType {
  /**
   * The engine checks if the group would fit on the current line if printed
   * in Flat mode. If so, it prints the group in Flat mode and Breaking mode
   * otherwise.
   */
  Auto,
  /**
   * The engine begins printing the group. When it encounters a break hint,
   * it checks if the following node would fit on the current line. If that
   * node is a Group, its Flat mode width is used for the check. If the node
   * would not fit, a break is emitted.
   */
  FitGroups,
  /**
   * The engine begins printing the group. When it encounters a break hint,
   * it checks if the following node would fit on the current line. If that
   * node is a Group, its Breaking mode width is used for the check. If the
   * node would not fit, a break is emitted.
   */
  FitAll,
}
/**
 * Represents a width that may or may not account for line breaks.
 */
and abstract enum Width {
  WithBreak(Number),
  WithoutBreak(Number),
}

let breakingWidth = doc => {
  match (doc) {
    Empty | GroupBreaker => WithoutBreak(0),
    String{ width, _ } => width,
    Indent{ breakingWidth, _ } |
    Group{ breakingWidth, _ } |
    Concat{ breakingWidth, _ } |
    IfBroken{ breakingWidth, _ } => breakingWidth,
    Blank{ count } => WithoutBreak(count),
    BreakHint{ _ } | Hardline{ phantom: false } => WithBreak(0),
    Hardline{ phantom: true } => WithoutBreak(0),
  }
}

let flatWidth = doc => {
  match (doc) {
    Empty | GroupBreaker => WithoutBreak(0),
    String{ width, _ } => width,
    Indent{ flatWidth, _ } |
    Group{ flatWidth, _ } |
    Concat{ flatWidth, _ } |
    IfBroken{ flatWidth, _ } |
    BreakHint{ flatWidth, _ } => flatWidth,
    Blank{ count } => WithoutBreak(count),
    Hardline{ phantom: false } => WithBreak(0),
    Hardline{ phantom: true } => WithoutBreak(0),
  }
}

let addWidth = (left, right) => {
  match (left) {
    WithBreak(l) => left,
    WithoutBreak(l) => match (right) {
      WithBreak(r) => WithBreak(l + r),
      WithoutBreak(r) => WithoutBreak(l + r),
    },
  }
}

let hasGroupBreaker = doc => {
  match (doc) {
    Concat{ hasGroupBreaker, _ } | Indent{ hasGroupBreaker, _ } =>
      hasGroupBreaker,
    GroupBreaker => true,
    Empty |
    IfBroken{ _ } |
    BreakHint{ _ } |
    Blank{ _ } |
    Hardline{ _ } |
    Group{ _ } |
    String{ _ } => false,
  }
}

let widthValue = width => {
  match (width) {
    WithBreak(w) | WithoutBreak(w) => w,
  }
}

/**
 * Utilities for constructing the document IR.
 */
provide module Builder {
  /**
   * An empty node that has no effect on the output of the printing engine.
   */
  provide let empty = Empty
  /**
   * A node that causes the enclosing group to be printed in Breaking mode.
   */
  provide let groupBreaker = GroupBreaker
  /**
   * A node that prints the char as-is. The `char`
   * function is Utf8-aware.
   *
   * @param str: The string to print
   *
   * @returns A LayoutNode that prints the string
   */
  provide let string = str =>
    String{ value: str, width: WithoutBreak(stringLength(str)) }
  /**
   * A node that prints the specified number of spaces.
   *
   * @param c: The number of spaces to print
   *
   * @returns A LayoutNode that prints the spaces
   */
  provide let blank = c => Blank{ count: c }
  /** Internal break hinting. */
  let _break = doc => BreakHint{ doc, flatWidth: flatWidth(doc) }
  /**
   * A node that forces the engine to print a newline character.
   * Width calculations for the current line are truncated at the Hardline.
   */
  provide let hardline = Hardline{ phantom: false }
  /**
   * A node that forces the engine to print a newline character.
   * Width calculations for the current line are truncated at the Hardline.
   * The Hardline is calculated as a zero-width non-breaking character (the
   * newline is emitted in the output, but calculations assume it's just not
   * there).
   */
  provide let phantomHardline = Hardline{ phantom: true }
  /**
   * Constructs a node where if the engine has broken the current group,
   * prints the `breaking` document and prints the `flat` document otherwise.
   * Note that for FitAll and FitGroups groups, the `flat` document would be
   * printed if the IfBroken node appears before the point at which the group
   * is broken, as the engine makes that decision while printing the group
   * (unlike default groups, where the engine makes this decision before
   * printing the group).
   *
   * @param breaking: The document to print if the group is broken
   * @param flat: The document to print if the group is not broken
   *
   * @returns A LayoutNode that conditionally prints one of the documents
   */
  provide let ifBroken = (breaking, flat) =>
    IfBroken{
      flat,
      breaking,
      flatWidth: flatWidth(flat),
      breakingWidth: breakingWidth(breaking),
    }
  /**
   * Constructs a node that introduces indentation equal to the number of spaces
   * specified when the enclosing group is broken. When newline characters are emitted,
   * they are followed by space characters equal to the amount of indentation that has
   * been applied by all groups, unless this would lead to trailing whitespace.
   * Note that if the enclosing group has not been broken, the
   * indentation will not apply. For example, in this document,
   * ```grain
   * group(~kind=FitGroups, indent(2,
   *  group(indent(2, string("foo") ++ break ++ string("bar")))
   * ))
   * if the break hint is broken by the engine, `bar`'s indentation level will
   * only be two spaces, as the outer group could never be broken be broken by
   * the engine.
   *
   * @param count: The number of spaces to indent by (default: 2)
   * @param doc: The document to indent
   *
   * @returns A LayoutNode that indents the document
   */
  provide let indent = (count=2, doc) =>
    Indent{
      count,
      doc,
      hasGroupBreaker: hasGroupBreaker(doc),
      flatWidth: flatWidth(doc),
      breakingWidth: breakingWidth(doc),
    }
  /**
   * Constructs a node that creates a group around the supplied document,
   * allowing the printing mode to be controlled.
   *
   * @param printWidth: An optional width to consider the group as when printing
   * @param kind: The kind of group to create (default: Auto)
   * @param doc: The document to group
   *
   * @returns A LayoutNode that groups the document
   */
  provide let group = (printWidth=None, kind=Auto, doc) => {
    match (printWidth) {
      Some(width) => {
        let width = WithBreak(width)
        Group{ groupType: kind, doc, flatWidth: width, breakingWidth: width }
      },
      None => {
        Group{
          groupType: kind,
          doc,
          flatWidth: flatWidth(doc),
          breakingWidth: breakingWidth(doc),
        }
      },
    }
  }
  /**
   * A node that prints the first document followed by the second document.
   * While keeping track of the combined width to allow the engine to make
   * constant-time decisions about line breaks.
   *
   * @param left: The first document
   * @param right: The second document
   *
   * @returns A LayoutNode that concatenates the documents
   */
  provide let (++) = (left, right) => {
    let hasGroupBreaker = hasGroupBreaker(left) || hasGroupBreaker(right)
    let breakingWidth = addWidth(breakingWidth(left), breakingWidth(right))

    Concat{
      left,
      right,
      hasGroupBreaker,
      flatWidth: if (hasGroupBreaker) {
        breakingWidth
      } else {
        addWidth(flatWidth(left), flatWidth(right))
      },
      breakingWidth,
    }
  }

  let rec concatMapHelp = (sep, trail, func, acc, lst) => {
    match (lst) {
      [] => throw Impossible("empty list in concatMap"),
      [ultimate] =>
        // one element list
        acc ++ func(final=true, ultimate) ++ trail(ultimate),
      [elem, next, ...rest] =>
        concatMapHelp(
          sep,
          trail,
          func,
          acc ++ func(final=false, elem) ++ sep(elem, next),
          [next, ...rest]
        ),
    }
  }
  /**
   * Maps over a list, applying the given function to each element
   * and concatenating the results.
   *
   * @param sep: A function that produces a separator to be placed between elements
   * @param lead: A function that produces a leading document before the first element
   * @param trail: A function that produces a trailing document after the last element
   * @param func: A function that produces a document for each element
   * @param lst: The list of elements to map over
   *
   * @returns A LayoutNode that represents the concatenated mapped documents
   */
  provide let concatMap = (sep, lead, trail, func, lst) => {
    match (lst) {
      [] => empty,
      [first, ..._] => concatMapHelp(sep, trail, func, lead(first), lst),
    }
  }

  /**
   * A node that represents a space that may be broken
   * if necessary.
   */
  provide let breakableSpace = _break(blank(1))
  /** A node that represents a break. */
  provide let _break = _break(Empty)
  /** A node that represents a space. */
  provide let space = blank(1)
  /** A node that represents a comma. */
  provide let comma = string(",")
  /** A node that represents a comma followed by a breakable space. */
  provide let commaBreakableSpace = comma ++ breakableSpace
  /**
   * Constructs a node wrapping the given document in parentheses.
   *
   * @param wrap: An optional wrapping function to apply (default: group)
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in parentheses
   */
  provide let parens = (wrap=doc => group(doc), doc) =>
    wrap(string("(") ++ doc ++ string(")"))
  /**
   * Constructs a node wrapping the given document in braces.
   *
   * @param wrap: An optional wrapping function to apply (default: group)
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in braces
   */
  provide let braces = (wrap=doc => group(doc), doc) =>
    wrap(string("{") ++ doc ++ string("}"))
  /**
   * Constructs a node wrapping the given document in array brackets.
   *
   * @param wrap: An optional wrapping function to apply (default: group)
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in array brackets
   */
  provide let arrayBrackets = (wrap=doc => group(doc), doc) =>
    wrap(string("[>") ++ doc ++ string("]"))
  /**
   * Constructs a node wrapping the given document in list brackets.
   *
   * @param wrap: An optional wrapping function to apply (default: group)
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in list brackets
   */
  provide let listBrackets = (wrap=doc => group(doc), doc) =>
    wrap(string("[") ++ doc ++ string("]"))
  /**
   * Constructs a node wrapping the given document in angle brackets.
   *
   * @param wrap: An optional wrapping function to apply (default: group)
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in angle brackets
   */
  provide let angleBrackets = (wrap=doc => group(doc), doc) =>
    wrap(string("<") ++ doc ++ string(">"))
  /**
   * Constructs a node wrapping the given document in double quotes.
   *
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in double quotes
   */
  provide let doubleQuotes = doc => string("\"") ++ doc ++ string("\"")
  /**
   * Constructs a node wrapping the given document in single quotes.
   *
   * @param doc: The document to wrap
   *
   * @returns A LayoutNode that wraps the document in single quotes
   */
  provide let singleQuotes = doc => string("'") ++ doc ++ string("'")
  /**
   * A node that represents a trailing comma to be added if the
   * current group is broken.
   */
  provide let trailingComma = ifBroken(comma, empty)
}

/**
 * The printing engine for LayoutNode documents.
 */
provide module Engine {
  enum EngineMode {
    Flat,
    Breaking,
    FitFlat,
    FitBreaking,
  }

  record EngineGroup {
    mode: EngineMode,
    mut globalIndent: Number,
    mut localIndent: Number,
    mut broken: Bool,
  }

  enum PrintInstruction {
    Print(EngineGroup, LayoutNode),
    UpdateIndent(EngineGroup, Number, Number),
  }

  /**
   * Prints the given document using the provided write function.
   *
   * @param write: A function that takes a string and writes it to an output
   * @param eol: The end-of-line style to use
   * @param lineWidth: The maximum line width to use
   * @param doc: The document to print
   *
   * @returns Void
   */
  provide let print = (write, eol, lineWidth, doc) => {
    // The current column we're writing to
    let mut column = 0
    // Queue for indentation to prevent lines with just spaces
    let mut writeQueue = None
    // Continuation for Fit mode calculations that depend on the size of the next node
    let mut k = None

    let eol = match (eol) {
      CRLF => "\r\n",
      LF => "\n",
    }

    let flushWriteQueue = () => {
      match (writeQueue) {
        Some(queued) => {
          write(queued)
          writeQueue = None
        },
        None => void,
      }
    }

    let group = { mode: Flat, globalIndent: 0, localIndent: 0, broken: false }
    let mut queue = [Print(group, doc)]

    while (true) {
      match (queue) {
        [] => break,
        [Print(group, doc), ...rest] => {
          queue = rest
          match (k) {
            Some(f) => {
              k = None
              f(doc)
            },
            None => void,
          }

          match (doc) {
            Empty | GroupBreaker => void,
            String{ value, width } => {
              flushWriteQueue()
              write(value)
              column += widthValue(width)
            },
            Blank{ count } => {
              flushWriteQueue()
              write(buildSpaceString(count))
              column += count
            },
            BreakHint{ doc, flatWidth: width } => {
              let _break = () => {
                group.broken = true
                group.globalIndent = group.globalIndent + group.localIndent
                group.localIndent = 0
                write(eol)
                writeQueue = Some(buildSpaceString(group.globalIndent))
                column = group.globalIndent
              }
              match (group.mode) {
                Flat => queue = [Print(group, doc), ...queue],
                Breaking => _break(),
                FitFlat => {
                  k = Some(nextDoc => {
                    let nextWidth = widthValue(flatWidth(nextDoc))
                    let hintWidth = widthValue(width)
                    if (column + hintWidth + nextWidth > lineWidth) {
                      _break()
                    } else {
                      queue = [Print(group, doc), ...queue]
                    }
                  })
                },
                FitBreaking => {
                  k = Some(nextDoc => {
                    let nextWidth = widthValue(breakingWidth(nextDoc))
                    let hintWidth = widthValue(width)
                    if (column + hintWidth + nextWidth > lineWidth) {
                      _break()
                    } else {
                      queue = [Print(group, doc), ...queue]
                    }
                  })
                },
              }
            },
            Hardline{ _ } => {
              group.broken = true
              group.globalIndent = group.globalIndent + group.localIndent
              group.localIndent = 0
              write(eol)
              writeQueue = Some(buildSpaceString(group.globalIndent))
              column = group.globalIndent
            },
            IfBroken{ flat, breaking, _ } => {
              queue = [
                Print(group, if (group.broken) breaking else flat),
                ...queue
              ]
            },
            Indent{ count, doc, _ } => {
              let globalIndent = group.globalIndent
              let localIndent = group.localIndent
              group.localIndent = localIndent + count
              queue = [
                Print(group, doc),
                UpdateIndent(group, globalIndent, localIndent),
                ...queue
              ]
            },
            Group{ doc, groupType, flatWidth, _ } => {
              let width = widthValue(flatWidth)
              let mode = match (groupType) {
                _ when hasGroupBreaker(doc) => Breaking,
                Auto when column + width > lineWidth => Breaking,
                Auto => Flat,
                FitGroups => FitFlat,
                FitAll => FitBreaking,
              }

              let group = {
                mode,
                globalIndent: group.globalIndent,
                localIndent: 0,
                broken: hasGroupBreaker(doc),
              }
              queue = [Print(group, doc), ...queue]
            },
            Concat{ left, right, _ } => {
              queue = [Print(group, left), Print(group, right), ...queue]
            },
          }
        },
        [UpdateIndent(group, globalIndent, localIndent), ...rest] => {
          queue = rest
          group.globalIndent = globalIndent
          group.localIndent = localIndent
        },
      }
    }
  }

  /**
   * Converts the given document to a string using the specified
   * end-of-line style and line width.
   *
   * @param eol: The end-of-line style to use
   * @param lineWidth: The maximum line width to use
   * @param doc: The document to convert to a string
   *
   * @returns The string representation of the document
   */
  provide let toString = (eol, lineWidth, doc) => {
    let b = MiniBuffer.make(2048)
    let write = str => MiniBuffer.addString(str, b)
    print(write, eol, lineWidth, doc)
    MiniBuffer.toString(b)
  }
}
