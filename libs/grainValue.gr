/*
 * Copyright (c) 2025 Jake Follest
 * Licensed under the MIT License.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies, subject to the MIT License.
 */

/**
 * Unsafe utilities for extracting runtime tag information from grain values.
 *
 *
 * Note:
 *   This module is unsafe and should be used with caution.
 *   The grain team offers no guarantees on breaking changes or
 *   end user support.
 */
@noPervasives
module GrainValue

from "runtime/unsafe/wasmi32" include WasmI32
use WasmI32.{
  (+),
  (-),
  (*),
  remS as (%),
  (&),
  (<<),
  (==),
  (!=),
  (>=),
  (<),
  (>),
}
from "runtime/unsafe/tags" include Tags
from "runtime/unsafe/offsets" include Offsets
use Offsets.{
  _STR_LEN_OFFSET,
  _STR_DATA_OFFSET,
  _ARRAY_DATA_OFFSET,
  _ARRAY_ITEM_SIZE,
}
from "runtime/unsafe/memory" include Memory
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  allocateString,
  allocateArray,
  untagSimpleNumber,
  tagSimpleNumber,
}

exception Impossible(String)

primitive arrayLength = "@array.length"
primitive magic = "@magic"
primitive builtinId = "@builtin.id"
primitive ignore = "@ignore"
primitive throw = "@throw"

@unsafe
let _ADT_ARITY_OFFSET = 16n
@unsafe
let _ADT_DATA_OFFSET = 20n
@unsafe
let _ADT_ITEM_SIZE = 4n

@unsafe
let _LIST_ID = untagSimpleNumber(builtinId("List"))
@unsafe
let _OPTION_ID = untagSimpleNumber(builtinId("Option"))
@unsafe
let _RESULT_ID = untagSimpleNumber(builtinId("Result"))
@unsafe
let _RANGE_ID = untagSimpleNumber(builtinId("Range"))

/** Represents a generic grain heap value. */
abstract type HeapValue<a> = a
/** Represents a generic grain short value. */
abstract type ShortValue<a> = a
/** Represents an unknown value. */
abstract type UnknownValue<a> = a
/** Represents a generic grain constant value. */
abstract type ConstantValue<a> = a
/** Represents a generic grain tuple value. */
abstract type TupleValue<a> = a
/** Represents a generic grain record value. */
abstract type RecordValue<a> = a
/** Represents a generic grain ADT value. */
abstract type ADTValue<a> = a
/** Represents a generic grain lambda value. */
abstract type LambdaValue<a> = a

/**
 * Represents a tagged grain number value.
 */
provide enum NumberTag {
  SimpleNumberTag(Number),
  Int64Tag(Int64),
  Float64Tag(Float64),
  RationalTag(Rational),
  BigIntTag(BigInt),
  UnknownNumberTag,
}

/**
 * Represents a tagged grain stack value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum StackTag<a> {
  /** simple number - 0bxx1 */
  NumberTag(Number),
  /** heap value - 0b00x */
  HeapTag(HeapValue<a>),
  /** short value - 0b01x */
  ShortTag(ShortValue<a>),
  /** reserved tag - 0b10x */
  UnknownTag,
  /** constant tag - 0b11x */
  ConstantTag(ConstantValue<a>),
}

/**
 * Represents a tagged grain heap value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum HeapTag<a> {
  TupleTag(TupleValue<a>),
  ArrayTag(Array<a>),
  RecordTag(RecordValue<a>),
  ADTTag(ADTValue<a>),
  ClosureTag(LambdaValue<a>),
  StringTag(String),
  BytesTag(Bytes),
  BoxedNumberTag(Number),
  Int32Tag(Int32),
  Float32Tag(Float32),
  Uint32Tag(Uint32),
  Uint64Tag(Uint64),
  UnknownTag,
}

/**
 * Represents a tagged grain short value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum ShortTag {
  /** Char - 0b00000 */
  CharTag(Char),
  /** Int8 - 0b00001 */
  Int8Tag(Int8),
  /** Int16 - 0b00010 */
  Int16Tag(Int16),
  /** Uint8 - 0b00011 */
  Uint8Tag(Uint8),
  /** Uint16 - 0b00100 */
  Uint16Tag(Uint16),
  /** Unknown short tag */
  UnknownShortTag,
}

// Stack tagging
@unsafe
provide let isSimpleNumberValue = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_NUMBER_TAG_MASK)
    == Tags._GRAIN_NUMBER_TAG_TYPE
}
@unsafe
provide let isHeapValue = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_GENERIC_HEAP_TAG_TYPE
}
@unsafe
let isConstantValue = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_CONST_TAG_TYPE
}
@unsafe
let isShortValue = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_SHORTVAL_TAG_TYPE
}

/**
 * Provides a tagged stack value based on the grain value type.
 *
 * @param value: The grain value to tag.
 *
 * @returns A tagged grain value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getTag = (value: a) => {
  if (isSimpleNumberValue(value)) {
    NumberTag(magic(value): Number)
  } else if (isHeapValue(value)) {
    HeapTag(magic(value): HeapValue<b>)
  } else if (isShortValue(value)) {
    ShortTag(magic(value): ShortValue<b>)
  } else if (isConstantValue(value)) {
    ConstantTag(magic(value): ConstantValue<b>)
  } else {
    UnknownTag
  }
}

/**
 * Provides a tagged heap value based on the grain value type.
 *
 * @param value: The grain heap value to tag.
 *
 * @returns A tagged grain heap value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getHeapTag = (value: HeapValue<a>) => {
  let ptr = WasmI32.fromGrain(value)
  let tag = WasmI32.load(ptr, 0n)
  ignore(value)
  if (tag == Tags._GRAIN_TUPLE_HEAP_TAG) {
    TupleTag(magic(value): TupleValue<b>)
  } else if (tag == Tags._GRAIN_ARRAY_HEAP_TAG) {
    ArrayTag(magic(value): Array<b>)
  } else if (tag == Tags._GRAIN_RECORD_HEAP_TAG) {
    RecordTag(magic(value): RecordValue<b>)
  } else if (tag == Tags._GRAIN_ADT_HEAP_TAG) {
    ADTTag(magic(value): ADTValue<b>)
  } else if (tag == Tags._GRAIN_LAMBDA_HEAP_TAG) {
    ClosureTag(magic(value): LambdaValue<b>)
  } else if (tag == Tags._GRAIN_STRING_HEAP_TAG) {
    StringTag(magic(value): String)
  } else if (tag == Tags._GRAIN_BYTES_HEAP_TAG) {
    BytesTag(magic(value): Bytes)
  } else if (tag == Tags._GRAIN_BOXED_NUM_HEAP_TAG) {
    BoxedNumberTag(magic(value): Number)
  } else if (tag == Tags._GRAIN_INT32_HEAP_TAG) {
    Int32Tag(magic(value): Int32)
  } else if (tag == Tags._GRAIN_FLOAT32_HEAP_TAG) {
    Float32Tag(magic(value): Float32)
  } else if (tag == Tags._GRAIN_UINT32_HEAP_TAG) {
    Uint32Tag(magic(value): Uint32)
  } else if (tag == Tags._GRAIN_UINT64_HEAP_TAG) {
    Uint64Tag(magic(value): Uint64)
  } else {
    UnknownTag
  }
}

/**
 * Provides a tagged number value based on the grain value type.
 *
 * @param value: The grain number value to tag.
 *
 * @returns A tagged grain number value that can be used to extract the value information.
 */
@unsafe
provide let getNumberTag = (value: Number) => {
  if (isSimpleNumberValue(value)) {
    SimpleNumberTag(magic(value): Number)
  } else {
    let ptr = WasmI32.fromGrain(value)
    let tag = WasmI32.load(ptr, 4n)
    ignore(value)
    if (tag == Tags._GRAIN_INT64_BOXED_NUM_TAG) {
      Int64Tag(magic(value): Int64)
    } else if (tag == Tags._GRAIN_FLOAT64_BOXED_NUM_TAG) {
      Float64Tag(magic(value): Float64)
    } else if (tag == Tags._GRAIN_RATIONAL_BOXED_NUM_TAG) {
      RationalTag(magic(value): Rational)
    } else if (tag == Tags._GRAIN_BIGINT_BOXED_NUM_TAG) {
      BigIntTag(magic(value): BigInt)
    } else {
      UnknownNumberTag
    }
  }
}

// Short tagging
@unsafe
let isChar = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_CHAR_SHORTVAL_TAG
}
@unsafe
let isInt8 = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_INT8_TAG_MASK
}
@unsafe
let isInt16 = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_INT16_TAG_MASK
}
@unsafe
let isUInt8 = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_UINT8_TAG_MASK
}
@unsafe
let isUInt16 = a => {
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_UINT16_TAG_MASK
}

/**
 * Provides a tagged short value based on the grain value type.
 *
 * @param value: The grain short value to tag.
 *
 * @returns A tagged grain short value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getShortTag = (value: ShortValue<a>) => {
  if (isChar(value)) {
    CharTag(magic(value): Char)
  } else if (isInt8(value)) {
    Int8Tag(magic(value): Int8)
  } else if (isInt16(value)) {
    Int16Tag(magic(value): Int16)
  } else if (isUInt8(value)) {
    Uint8Tag(magic(value): Uint8)
  } else if (isUInt16(value)) {
    Uint16Tag(magic(value): Uint16)
  } else {
    UnknownShortTag
  }
}

/**
 * Provides the tuples tagged contents.
 *
 * @param value: The tagged grain tuple value to extract data from
 *
 * @returns A list of tagged values representing the tuple's fields
 *
 */
@unsafe
provide let getTupleData = (value: TupleValue<a>) => {
  let ptr = WasmI32.fromGrain(value)
  let len = WasmI32.load(ptr, 4n)
  let mut vals = []
  for (let mut i = len * 4n - 4n; i >= 0n; i -= 4n) {
    let fieldPtr = WasmI32.load(ptr + 8n, i)
    let fieldVal = WasmI32.toGrain(fieldPtr): b
    vals = [getTag(fieldVal), ...vals]
  }
  ignore(value)
  vals
}

/**
 * Provides the array's tagged contents.
 *
 * @param value: The tagged grain array value to extract data from
 *
 * @returns A list of tagged values representing the array's elements
 */
@unsafe
provide let getArrayData = (value: Array<a>) => {
  let mut ptr = WasmI32.fromGrain(value)
  ptr += _ARRAY_DATA_OFFSET
  let len = (untagSimpleNumber(arrayLength(value)) - 1n) * _ARRAY_ITEM_SIZE
  let mut vals = []
  for (let mut i = len; i >= 0n; i -= _ARRAY_ITEM_SIZE) {
    let elementPtr = WasmI32.load(ptr, i)
    let elementVal = WasmI32.toGrain(elementPtr): b
    vals = [getTag(elementVal), ...vals]
  }
  ignore(value)
  vals
}

module TypeMetaData {
  @unsafe
  primitive typeMetadata = "@heap.type_metadata"

  /**
   * Finds the type metadata block for a given type hash.
   *
   * @param typeHash: The type hash to find metadata for
   *
   * @returns Pointer to the type metadata block, or -1n if not found
   */
  @unsafe
  provide let findTypeMetadata = typeHash => {
    // Get the pointer to the type metadata table
    let mut typeMetadata = typeMetadata()
    let numBuckets = WasmI32.load(typeMetadata, 0n)
    // Locate the block
    let bucketHash = (typeHash % numBuckets) << 3n // 8 bytes per entry
    let bucketPtr = typeMetadata + 8n + bucketHash // First 8 bytes of metadata are for table size
    // Locate the bucket
    let bucketOffset = WasmI32.load(bucketPtr, 0n)
    let bucketSize = WasmI32.load(bucketPtr, 4n)
    // Scan the bucket entries for matching type hash
    let startPtr = typeMetadata + bucketOffset
    let endPtr = startPtr + (bucketSize << 3n) // 8 bytes per entry
    for (let mut blockPtr = startPtr; blockPtr < endPtr; blockPtr += 8n) {
      let blockHash = WasmI32.load(blockPtr, 0n)
      if (blockHash == typeHash) {
        return typeMetadata + WasmI32.load(blockPtr, 4n) // Metadata pointer
      }
    }
    return -1n
  }

  /**
   * Provides the metadata for a record type.
   *
   * @param metaDataPtr: Pointer to the record metadata block
   * @param typeTag: The record type tag
   * @param arity: Number of fields in the record
   *
   * @returns The names of the fields in the record, or an empty array if none found
   */
  @unsafe
  provide let getRecordMetaData = (metaDataPtr, typeTag, arity) => {
    if (metaDataPtr == -1n) {
      // Possible built-in record type
      if (typeTag == _RANGE_ID) {
        [> "rangeStart", "rangeEnd"]
      } else {
        [>]
      }
    } else {
      // +0  32-bit size of complete type info block
      // <start repeated pattern>
      // +0  32-bit size of record field name block
      // +4  32-bit length of record field name
      // +8  n-bit string
      // <end repeated pattern>
      let metaDataSize = WasmI32.load(metaDataPtr, 0n)
      let metaDataEndPtr = metaDataPtr + metaDataSize
      let mut metaDataPtr = metaDataPtr + 4n // Skip block size field
      // Read Blocks
      let fieldArray = WasmI32.toGrain(allocateArray(arity)): Array<String>
      for (let mut i = 0n; i < arity; i += 1n) {
        if (metaDataPtr > metaDataEndPtr)
          throw Impossible("Invalid record metadata")
        // Read the field
        let fieldBlockSize = WasmI32.load(metaDataPtr, 0n)
        let fieldLength = WasmI32.load(metaDataPtr, 4n)
        let fieldName = allocateString(fieldLength)
        Memory.copy(
          fieldName + _STR_LEN_OFFSET,
          metaDataPtr + 4n, // +4 to skip field size
          fieldLength + 4n // +4 for 32-bit field length
        )
        fieldArray[tagSimpleNumber(i)] = WasmI32.toGrain(fieldName): String
        // Advance to next field
        metaDataPtr += fieldBlockSize
      }
      fieldArray
    }
  }

  /**
   * Provides the metadata for a variant type.
   *
   * @param metaDataPtr: Pointer to the variant metadata block
   * @param typeTag: The variant type tag
   * @param variantTag: The variant tag
   * @param arity: Number of fields in the variant
   *
   * @returns The name and fields of the variant
   */
  @unsafe
  provide let getVariantMetaData = (metaDataPtr, typeTag, variantTag, arity) => {
    if (metaDataPtr == -1n) {
      if (typeTag == _OPTION_ID) {
        return (if (variantTag == 0n) {
          "Some"
        } else {
          "None"
        }, [>])
      } else if (typeTag == _RESULT_ID) {
        return (if (variantTag == 0n) {
          "Ok"
        } else {
          "Err"
        }, [>])
      } else {
        return ("<unknown variant>", [>])
      }
    } else {
      // +0  32-bit size of complete type info block
      // <start repeated pattern>
      // +0  32-bit size of constructor name block
      // +4  32-bit offset to field data (for inline record constructors) or 0 (for tuple-like constructors)
      // +4  32-bit constructor id
      // +8  32-bit length of constructor name
      // +12 n-bit string
      //   <start repeated pattern> (only for inline record constructors)
      //   +0  32-bit size of record field name block
      //   +4  32-bit length of record field name
      //   +8  n-bit string
      //   <end repeated pattern>
      // <end repeated pattern>
      let metaDataSize = WasmI32.load(metaDataPtr, 0n)
      let metaDataEndPtr = metaDataPtr + metaDataSize
      let mut currentPtr = metaDataPtr + 4n // Skip block size field
      // Locate the variant metadata
      while (currentPtr < metaDataEndPtr) {
        // Check variant tag
        let constructorBlockSize = WasmI32.load(currentPtr, 0n)
        let constructorId = WasmI32.load(currentPtr, 8n)
        if (constructorId != variantTag) {
          currentPtr += constructorBlockSize
          continue
        }
        // Read Variant Name
        let nameLength = WasmI32.load(currentPtr, 12n)
        let name = allocateString(nameLength)
        Memory.copy(
          name + _STR_LEN_OFFSET,
          currentPtr + 12n, // +16 to skip size(4) + offset(4) + id(4)
          nameLength + 4n // +4 for 32-bit field length
        )
        // Read Variant Fields
        let fieldOffset = WasmI32.load(currentPtr, 4n)
        if (fieldOffset == 0n) return (WasmI32.toGrain(name): String, [>]) // Tuple variant
        let fieldArray = WasmI32.toGrain(allocateArray(arity)): Array<String>
        let mut fieldMetaDataPtr = currentPtr + fieldOffset
        for (let mut i = 0n; i < arity; i += 1n) {
          // Read the field
          let fieldBlockSize = WasmI32.load(fieldMetaDataPtr, 0n)
          let fieldLength = WasmI32.load(fieldMetaDataPtr, 4n)
          let fieldName = allocateString(fieldLength)
          Memory.copy(
            fieldName + _STR_LEN_OFFSET,
            fieldMetaDataPtr + 4n, // +4 to skip field size
            fieldLength + 4n // +4 for 32-bit field length
          )
          fieldArray[tagSimpleNumber(i)] = WasmI32.toGrain(fieldName): String
          // Advance to next field
          fieldMetaDataPtr += fieldBlockSize
        }
        return (WasmI32.toGrain(name): String, fieldArray)
      }
      throw Impossible("Invalid variant metadata")
    }
  }
}

/**
 * Provides the record's tagged field data.
 *
 * @param record_: The tagged record value to extract data from
 *
 * @returns An associated list of field names and their tagged values
 */
@unsafe
provide let getRecordData = (record_: RecordValue<a>) => {
  // ╔══════╦═══════════╤═══════════╤══════════╤════════╤═══════╤═════╤═══════╗
  // ║ size ║ 32        │ 32        │ 32       │ 32     │ 32    │ 32  │ 32    ║
  // ╠══════╬═══════════╪═══════════╪══════════╪════════╪═══════╪═════╪═══════╣
  // ║ what ║ value tag │ type hash │ type tag │ length │ elt_0 │ ... │ elt_n ║
  // ╚══════╩═══════════╧═══════════╧══════════╧════════╧═══════╧═════╧═══════╝
  let mut ptr = WasmI32.fromGrain(record_)
  let typeHash = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 4n)): Number
  )
  let typeTag = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 8n)): Number
  )
  let arity = WasmI32.load(ptr, 12n)
  ptr += 16n + (arity - 1n) * 4n // Advance to the start of the last element
  // Lookup Metadata
  let metaDataPtr = TypeMetaData.findTypeMetadata(typeHash)
  // Get field names
  let fieldNames = TypeMetaData.getRecordMetaData(metaDataPtr, typeTag, arity)
  let fieldNamesLen = untagSimpleNumber(arrayLength(fieldNames))
  // Get field data
  let mut fieldData = []
  for (let mut i = arity - 1n; i >= 0n; i -= 1n) {
    // Determine field name
    let name = if (fieldNamesLen == 0n) {
      "<unknown field>"
    } else {
      fieldNames[tagSimpleNumber(i)]
    }
    // Determine field value
    let fieldPtr = WasmI32.load(ptr, 0n)
    let fieldValue = WasmI32.toGrain(fieldPtr): b
    let value = getTag(fieldValue)
    ptr -= 4n // Move to previous element
    // Pack data
    fieldData = [(name, value), ...fieldData]
  }
  ignore(record_)
  fieldData
}

/**
 * Represents the variant's field data types.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum VariantType<a> {
  /** A variant with no attached data. */
  EmptyVariant,
  /** A variant with tuple data attached. */
  TupleVariant(List<StackTag<a>>),
  /** A variant with record data attached. */
  RecordVariant(List<(String, StackTag<a>)>),
}

/**
 * Provides the variant's tagged field data.
 *
 * @param variant: The tagged variant value to extract data from
 *
 * @returns The name and field data of the variant
 */
@unsafe
provide let getVariantData = (variant: ADTValue<a>) => {
  // ╔══════╦═══════════╤═══════════╤══════════╤═════════════╤═══════╤═══════╤═════╤═══════╗
  // ║ size ║ 32        │ 32        │ 32       │ 32          │ 32    │ 32    │ 32  │ 32    ║
  // ╠══════╬═══════════╪═══════════╪══════════╪═════════════╪═══════╪═══════╪═════╪═══════╣
  // ║ what ║ value tag │ type hash │ type tag │ variant tag │ arity │ elt_0 │ ... │ elt_n ║
  // ╚══════╩═══════════╧═══════════╧══════════╧═════════════╧═══════╧═══════╧═════╧═══════╝
  let mut ptr = WasmI32.fromGrain(variant)
  let typeHash = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 4n)): Number
  )
  let typeTag = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 8n)): Number
  )
  let variantTag = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 12n)): Number
  )
  let arity = WasmI32.load(ptr, 16n)
  ptr += 20n + (arity - 1n) * 4n // Advance to the start of the last element
  // Lookup Metadata
  let metaDataPtr = TypeMetaData.findTypeMetadata(typeHash)
  // Get Names
  let (name, fields) = TypeMetaData.getVariantMetaData(
    metaDataPtr,
    typeTag,
    variantTag,
    arity
  )
  let fieldNamesLen = untagSimpleNumber(arrayLength(fields))
  if (arity == 0n) return (name, EmptyVariant)
  // Get Data
  let data = WasmI32.toGrain(allocateArray(arity)): Array<StackTag<b>>
  for (let mut i = arity - 1n; i >= 0n; i -= 1n) {
    // Determine field value
    let fieldPtr = WasmI32.load(ptr, 0n)
    let fieldValue = WasmI32.toGrain(fieldPtr): c
    let value = getTag(fieldValue)
    ptr -= 4n // Move to previous element
    // Pack data
    data[tagSimpleNumber(i)] = value
  }
  ignore(variant)
  // Pack Data
  return (name, if (fieldNamesLen == 0n) {
    // Tuple Variant
    let mut fieldValues = []
    for (let mut i = arity - 1n; i >= 0n; i -= 1n) {
      let value = data[tagSimpleNumber(i)]
      fieldValues = [value, ...fieldValues]
    }
    TupleVariant(fieldValues)
  } else {
    // Record Variant
    let mut fieldData = []
    for (let mut i = arity - 1n; i >= 0n; i -= 1n) {
      let name = fields[tagSimpleNumber(i)]
      let value = data[tagSimpleNumber(i)]
      fieldData = [(name, value), ...fieldData]
    }
    RecordVariant(fieldData)
  })
}

/**
 * Checks if the given ADT value is a List variant.
 *
 * @param value: The ADT value to check.
 *
 * @returns `true` if the ADT value is a List variant, `false` otherwise.
 */
@unsafe
provide let isListVariant = (value: ADTValue<a>) => {
  let ptr = WasmI32.fromGrain(value)
  let typeId = untagSimpleNumber(WasmI32.toGrain(WasmI32.load(ptr, 8n)): Number)
  typeId == _LIST_ID
}
