/**
 * Unsafe utilities for extracting runtime tag information from grain values.
 *
 *
 * Note:
 *   This module is unsafe and should be used with caution.
 *   The grain team offers no guarantees on breaking changes or
 *   end user support.
 */
@noPervasives
module GrainValue

from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/tags" include Tags
from "runtime/unsafe/offsets" include Offsets
use Offsets.{ _STR_LEN_OFFSET, _STR_DATA_OFFSET }
from "runtime/unsafe/memory" include Memory
from "runtime/dataStructures" include DataStructures
use DataStructures.{ allocateString, allocateArray, untagSimpleNumber }

@unsafe
let _ADT_ARITY_OFFSET = 16n
@unsafe
let _ADT_DATA_OFFSET = 20n
@unsafe
let _ADT_ITEM_SIZE = 4n

primitive magic = "@magic"
primitive builtinId = "@builtin.id"
primitive ignore = "@ignore"

@unsafe
let _LIST_ID = untagSimpleNumber(builtinId("List"))
@unsafe
let _OPTION_ID = untagSimpleNumber(builtinId("Option"))
@unsafe
let _RESULT_ID = untagSimpleNumber(builtinId("Result"))
@unsafe
let _RANGE_ID = untagSimpleNumber(builtinId("Range"))

// TODO: Is there a better way to have completely abstract types?
/** Represents a generic grain heap value. */
abstract type HeapValue<a> = a
/** Represents a generic grain short value. */
abstract type ShortValue<a> = a
/** Represents an unknown value. */
abstract type UnknownValue<a> = a
/** Represents a generic grain constant value. */
abstract type ConstantValue<a> = a
/** Represents a generic grain tuple value. */
abstract type TupleValue<a> = a
/** Represents a generic grain record value. */
abstract type RecordValue<a> = a
/** Represents a generic grain ADT value. */
abstract type ADTValue<a> = a
/** Represents a generic grain lambda value. */
abstract type LambdaValue<a> = a

/**
 * Represents a tagged grain number value.
 */
provide enum NumberTag {
  SimpleNumberTag(Number),
  Int64Tag(Int64),
  Float64Tag(Float64),
  RationalTag(Rational),
  BigIntTag(BigInt),
  UnknownNumberTag,
}

/**
 * Represents a tagged grain stack value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum StackTag<a> {
  /** simple number - 0bxx1 */
  NumberTag(Number),
  /** heap value - 0b00x */
  HeapTag(HeapValue<a>),
  /** short value - 0b01x */
  ShortTag(ShortValue<a>),
  /** reserved tag - 0b10x */
  ReservedTag(UnknownValue<a>),
  /** constant tag - 0b11x */
  ConstantTag(ConstantValue<a>),
}

/**
 * Represents a tagged grain heap value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum HeapTag<a> {
  TupleTag(TupleValue<a>),
  ArrayTag(Array<a>),
  RecordTag(RecordValue<a>),
  ADTTag(ADTValue<a>),
  ClosureTag(LambdaValue<a>),
  StringTag(String),
  BytesTag(Bytes),
  BoxedNumberTag(Number),
  Int32Tag(Int32),
  Float32Tag(Float32),
  Uint32Tag(Uint32),
  Uint64Tag(Uint64),
  UnknownTag,
}

/**
 * Represents a tagged grain short value.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
provide enum ShortTag {
  /** Char - 0b00000 */
  CharTag(Char),
  /** Int8 - 0b00001 */
  Int8Tag(Int8),
  /** Int16 - 0b00010 */
  Int16Tag(Int16),
  /** Uint8 - 0b00011 */
  Uint8Tag(Uint8),
  /** Uint16 - 0b00100 */
  Uint16Tag(Uint16),
  /** Unknown short tag */
  UnknownShortTag,
}

// Stack tagging
@unsafe
provide let isSimpleNumberValue = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_NUMBER_TAG_MASK)
    == Tags._GRAIN_NUMBER_TAG_TYPE
}
@unsafe
provide let isHeapValue = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_GENERIC_HEAP_TAG_TYPE
}
@unsafe
let isConstantValue = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_CONST_TAG_TYPE
}
@unsafe
let isShortValue = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_TAG_MASK)
    == Tags._GRAIN_SHORTVAL_TAG_TYPE
}

/**
 * Provides a tagged stack value based on the grain value type.
 *
 * @param value: The grain value to tag.
 *
 * @returns A tagged grain value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getTag = (value: a) => {
  match (value) {
    _ when isSimpleNumberValue(value) => NumberTag(magic(value): Number),
    _ when isHeapValue(value) => HeapTag(magic(value): HeapValue<b>),
    _ when isShortValue(value) => ShortTag(magic(value): ShortValue<b>),
    _ when isConstantValue(value) =>
      ConstantTag(magic(value): ConstantValue<b>),
    _ => ReservedTag(magic(value): UnknownValue<b>),
  }
}

/**
 * Provides a tagged heap value based on the grain value type.
 *
 * @param value: The grain heap value to tag.
 *
 * @returns A tagged grain heap value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getHeapTag = (value: HeapValue<a>) => {
  use WasmI32.{ (==) }
  let ptr = WasmI32.fromGrain(value)
  let tag = WasmI32.load(ptr, 0n)
  let tagged = match (tag) {
    _ when tag == Tags._GRAIN_TUPLE_HEAP_TAG =>
      TupleTag(magic(value): TupleValue<b>),
    _ when tag == Tags._GRAIN_ARRAY_HEAP_TAG =>
      ArrayTag(magic(value): Array<b>),
    _ when tag == Tags._GRAIN_RECORD_HEAP_TAG =>
      RecordTag(magic(value): RecordValue<b>),
    _ when tag == Tags._GRAIN_ADT_HEAP_TAG => ADTTag(magic(value): ADTValue<b>),
    _ when tag == Tags._GRAIN_LAMBDA_HEAP_TAG =>
      ClosureTag(magic(value): LambdaValue<b>),
    _ when tag == Tags._GRAIN_STRING_HEAP_TAG =>
      StringTag(magic(value): String),
    _ when tag == Tags._GRAIN_BYTES_HEAP_TAG => BytesTag(magic(value): Bytes),
    _ when tag == Tags._GRAIN_BOXED_NUM_HEAP_TAG =>
      BoxedNumberTag(magic(value): Number),
    _ when tag == Tags._GRAIN_INT32_HEAP_TAG => Int32Tag(magic(value): Int32),
    _ when tag == Tags._GRAIN_FLOAT32_HEAP_TAG =>
      Float32Tag(magic(value): Float32),
    _ when tag == Tags._GRAIN_UINT32_HEAP_TAG =>
      Uint32Tag(magic(value): Uint32),
    _ when tag == Tags._GRAIN_UINT64_HEAP_TAG =>
      Uint64Tag(magic(value): Uint64),
    _ => UnknownTag,
  }
  ignore(value)
  return tagged
}

/**
 * Provides a tagged number value based on the grain value type.
 *
 * @param value: The grain number value to tag.
 *
 * @returns A tagged grain number value that can be used to extract the value information.
 */
@unsafe
provide let getNumberTag = (value: Number) => {
  use WasmI32.{ (==) }
  if (isSimpleNumberValue(value)) {
    SimpleNumberTag(magic(value): Number)
  } else {
    let ptr = WasmI32.fromGrain(value)
    let tag = WasmI32.load(ptr, 4n)
    let tagged = match (tag) {
      _ when tag == Tags._GRAIN_INT64_BOXED_NUM_TAG =>
        Int64Tag(magic(value): Int64),
      _ when tag == Tags._GRAIN_FLOAT64_BOXED_NUM_TAG =>
        Float64Tag(magic(value): Float64),
      _ when tag == Tags._GRAIN_RATIONAL_BOXED_NUM_TAG =>
        RationalTag(magic(value): Rational),
      _ when tag == Tags._GRAIN_BIGINT_BOXED_NUM_TAG =>
        BigIntTag(magic(value): BigInt),
      _ => UnknownNumberTag,
    }
    ignore(value)
    tagged
  }
}

// Short tagging
@unsafe
let isChar = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_CHAR_SHORTVAL_TAG
}
@unsafe
let isInt8 = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_INT8_TAG_MASK
}
@unsafe
let isInt16 = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_INT16_TAG_MASK
}
@unsafe
let isUInt8 = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_UINT8_TAG_MASK
}
@unsafe
let isUInt16 = a => {
  use WasmI32.{ (&), (==) }
  (WasmI32.fromGrain(a) & Tags._GRAIN_GENERIC_SHORTVAL_TAG_MASK)
    == Tags._GRAIN_UINT16_TAG_MASK
}

/**
 * Provides a tagged short value based on the grain value type.
 *
 * @param value: The grain short value to tag.
 *
 * @returns A tagged grain short value that can be used to extract the value information.
 *
 * Note: The `a` is `forall a`, meaning we never want to unify it.
 */
@unsafe
provide let getShortTag = (value: ShortValue<a>) => {
  match (value) {
    _ when isChar(value) => CharTag(magic(value): Char),
    _ when isInt8(value) => Int8Tag(magic(value): Int8),
    _ when isInt16(value) => Int16Tag(magic(value): Int16),
    _ when isUInt8(value) => Uint8Tag(magic(value): Uint8),
    _ when isUInt16(value) => Uint16Tag(magic(value): Uint16),
    _ => UnknownShortTag,
  }
}

/**
 * Provides the tuples tagged contents.
 *
 * @param value: The tagged grain tuple value to extract data from.
 *
 * @returns A list of tagged values representing the tuple's fields.
 *
 */
@unsafe
provide let getTupleData = (value: TupleValue<a>) => {
  use WasmI32.{ (+), (-), (*), (==), (>=) }
  let ptr = WasmI32.fromGrain(value)
  let len = WasmI32.load(ptr, 4n) // TODO: Magic Offset
  let mut vals = []
  for (let mut i = len * 4n - 4n; i >= 0n; i -= 4n) { // TODO: Magic Offset
    let fieldPtr = WasmI32.load(ptr + 8n, i) // TODO: Magic Offset
    let fieldVal = WasmI32.toGrain(fieldPtr): a
    vals = [getTag(fieldVal), ...vals]
  }
  ignore(value)
  vals
}

module TypeMetaData {
  // TODO: Figure out how this works and if we can optimize it, or make it safer
  use WasmI32.{ remS as (%), (+), (<<), (<), (>>), (==) }
  // NOTE: This code is taken directly from the grain runtime runtime/string.gr
  /*
   * MIT License
   * Copyright (c) 2017-2025 Oscar Spencer <oscar@grain-lang.org> and Philip Blair <philip@grain-lang.org>
   */
  @unsafe
  primitive typeMetadata = "@heap.type_metadata"

  @unsafe
  let findTypeMetadata = typeHash => {
    let typeMetadata = typeMetadata()
    let numBuckets = WasmI32.load(typeMetadata, 0n)
    let hashHash = typeHash % numBuckets
    // First 8 bytes of metadata are for table size
    let bucketPtr = typeMetadata + 8n + (hashHash << 3n) // 8 bytes/bucket
    let bucketDataOffset = WasmI32.load(bucketPtr, 0n)
    let bucketSize = WasmI32.load(bucketPtr, 4n)
    let beginDataPtr = typeMetadata + bucketDataOffset
    let endDataPtr = beginDataPtr + (bucketSize << 3n)
    for (let mut ptr = beginDataPtr; ptr < endDataPtr; ptr += 8n) {
      if (WasmI32.load(ptr, 0n) == typeHash) {
        return typeMetadata + WasmI32.load(ptr, 4n)
      }
    }
    return -1n
  }

  @unsafe
  provide let getVariantMetadata = variant => {
    let typeHash = WasmI32.load(variant, 4n) >> 1n
    let variantId = WasmI32.load(variant, 12n) >> 1n
    let mut block = findTypeMetadata(typeHash)
    if (block == -1n) return -1n
    let sectionLength = WasmI32.load(block, 0n)
    block += 4n
    let end = block + sectionLength
    while (block < end) {
      if (WasmI32.load(block, 8n) == variantId) {
        return block
      }
      block += WasmI32.load(block, 0n)
    }
    return -1n
  }

  @unsafe
  provide let getRecordMetadata = record_ => {
    let typeHash = WasmI32.load(record_, 4n) >> 1n
    return findTypeMetadata(typeHash)
  }

  @unsafe
  provide let getFieldArray = (metaDataPtr, arity) => {
    use WasmI32.{ (+), (*) }
    let fieldArray = allocateArray(arity)
    let mut fieldOffset = 0n
    for (let mut i = 0n; i < arity; i += 1n) {
      let fieldLength = WasmI32.load(metaDataPtr + fieldOffset, 4n) // TODO: Magic Offset
      let fieldName = allocateString(fieldLength)
      Memory.incRef(fieldName)
      Memory.copy(fieldName + 8n, metaDataPtr + fieldOffset + 8n, fieldLength) // TODO: Magic Offset
      WasmI32.store(fieldArray + 8n, fieldName, i * 4n) // TODO: Magic Offset
      fieldOffset += WasmI32.load(metaDataPtr, fieldOffset) // TODO: Magic Offset
    }
    fieldArray
  }
}

@unsafe
let rec getFieldNames = (data: List<StackTag<a>>, metaDataPtr: WasmI32) => {
  use WasmI32.{ (+) }
  match (data) {
    [] => [],
    [item, ...tail] => {
      // Get field name
      let blockSize = WasmI32.load(metaDataPtr, 0n) // TODO: Magic Offset
      let fieldLength = WasmI32.load(metaDataPtr, 4n) // TODO: Magic Offset
      let fieldName = allocateString(fieldLength)
      Memory.copy(
        fieldName + _STR_LEN_OFFSET,
        metaDataPtr + 4n, // TODO: Magic Offset
        fieldLength + 8n // TODO: Magic Offset
      )
      let fieldName = WasmI32.toGrain(fieldName): String
      [(fieldName, item), ...getFieldNames(tail, metaDataPtr + blockSize)]
    },
  }
}

let rec zipList = (list1, list2) => {
  match ((list1, list2)) {
    ([], _) => [],
    (_, []) => [],
    ([head1, ...tail1], [head2, ...tail2]) =>
      [(head1, head2), ...zipList(tail1, tail2)],
  }
}

@unsafe
provide let getRecordData = (value: RecordValue<a>) => {
  use WasmI32.{ (+), (-), (*), (>=), (>), (==), (>>) }
  let ptr = WasmI32.fromGrain(value)
  let arity = WasmI32.load(ptr, 12n) * 4n // TODO: Magic Offset
  let mut vals = []
  for (let mut i = arity; i > 0n; i -= 4n) { // TODO: Magic Offset
    let fieldPtr = WasmI32.load(ptr, 12n + i) // TODO: Magic Offset
    let fieldVal = WasmI32.toGrain(fieldPtr): a
    vals = [getTag(fieldVal), ...vals]
  }
  ignore(value)
  let metaDataPtr = TypeMetaData.getRecordMetadata(ptr)
  if (metaDataPtr == -1n) {
    // Could be built-in
    let typeId = WasmI32.load(ptr, 8n) >> 1n // TODO: Magic Offset
    if (typeId == _RANGE_ID) {
      Some(zipList(["rangeStart", "rangeEnd"], vals))
    } else {
      None
    }
  } else {
    Some(getFieldNames(vals, metaDataPtr + 4n)) // TODO: Magic Offset
  }
}

provide enum VariantType<a> {
  EmptyVariant,
  TupleVariant(List<StackTag<a>>),
  RecordVariant(List<(String, StackTag<a>)>),
}

@unsafe
provide let isListADT = (value: ADTValue<a>) => {
  use WasmI32.{ (==), (>>) }
  let ptr = WasmI32.fromGrain(value)
  let typeId = WasmI32.load(ptr, 8n) >> 1n // TODO: Magic Offset
  typeId == _LIST_ID
}

@unsafe
provide let getADTData = (value: ADTValue<a>) => {
  use WasmI32.{ (+), (-), (*), (==), (>=), (<) }
  let ptr = WasmI32.fromGrain(value)
  // TODO: Magic offsets
  let typeId = untagSimpleNumber(WasmI32.toGrain(WasmI32.load(ptr, 8n)): Number)
  let variantId = untagSimpleNumber(
    WasmI32.toGrain(WasmI32.load(ptr, 12n)): Number
  )
  let arity = WasmI32.load(ptr, _ADT_ARITY_OFFSET) * _ADT_ITEM_SIZE
  // Get Variant Data
  let mut dataList = []
  for (let mut i = arity - 4n; i >= 0n; i -= _ADT_ITEM_SIZE) {
    let variantValue = WasmI32.load(ptr, i + _ADT_DATA_OFFSET)
    let variantValue = WasmI32.toGrain(variantValue): b
    let variantValue = getTag(variantValue)
    dataList = [variantValue, ...dataList]
  }
  // Get MetaData
  let metaDataPtr = TypeMetaData.getVariantMetadata(ptr)
  // Handle MetaData
  let result = if (metaDataPtr == -1n) {
    // Could be built-in
    let name = if (typeId == _OPTION_ID) {
      Some(if (variantId == 0n) {
        "Some"
      } else {
        "None"
      })
    } else if (typeId == _RESULT_ID) {
      Some(if (variantId == 0n) {
        "Ok"
      } else {
        "Err"
      })
    } else {
      None
    }
    (name, if (arity == 0n) {
      EmptyVariant
    } else {
      TupleVariant(dataList)
    })
  } else {
    // Get the variant name
    let variantNameLength = WasmI32.load(metaDataPtr, 12n) // TODO: Magic Offset
    let variantName = allocateString(variantNameLength)
    Memory.copy(
      variantName + _STR_DATA_OFFSET,
      metaDataPtr + 16n, // TODO: Magic Offset
      variantNameLength
    )
    let variantName = WasmI32.toGrain(variantName): String
    // Get the variant field names
    let recordFieldDataOffset = WasmI32.load(metaDataPtr, 4n) // TODO: Magic Offset
    // Return Empty Variant
    if (arity == 0n) {
      (Some(variantName), EmptyVariant)
    } else if (recordFieldDataOffset == 0n) {
      (Some(variantName), TupleVariant(dataList))
    } else {
      let dataList = getFieldNames(
        dataList,
        metaDataPtr + recordFieldDataOffset
      )
      (Some(variantName), RecordVariant(dataList))
    }
  }
  ignore(value)
  result
}
