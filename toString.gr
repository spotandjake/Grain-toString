/*
 * toString.gr
 * Copyright (c) 2025 Jake Follest
 *
 * This file uses code from `libs/doc.gr`, which is licensed under the GPL.
 * Your use of this file is therefore subject to the GPL license.
 *
 * Original contributions by Jake Follest are MIT licensed, but redistribution
 * must comply with the GPL where the GPL code is used.
 */
@noPervasives
module ToString

from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/wasmf64" include WasmF64
from "runtime/unsafe/memory" include Memory
from "runtime/unsafe/offsets" include Offsets
use Offsets.{
  _BYTES_LEN_OFFSET,
  _BYTES_DATA_OFFSET,
  _STR_LEN_OFFSET,
  _STR_DATA_OFFSET,
}
from "runtime/bigint" include Bigint
from "runtime/numberUtils" include NumberUtils
from "runtime/dataStructures" include DataStructures
use DataStructures.{
  allocateString,
  // Tagging
  tagSimpleNumber,
  untagSimpleNumber,
  // Short Values
  untagChar,
  untagInt8,
  untagInt16,
  untagUint8,
  untagUint16,
}
from "runtime/utf8" include Utf8
use Utf8.{ usvEncodeLength, writeUtf8CodePoint }
from "./libs/grainValue.gr" include GrainValue
from "./libs/doc.gr" include Doc

@unsafe
let _RATIONAL_NUMERATOR_OFFSET = 8n
@unsafe
let _RATIONAL_DENOMINATOR_OFFSET = 12n

primitive ignore = "@ignore"
primitive (!) = "@not"
primitive (&&) = "@and"
primitive (is) = "@is"
primitive magic = "@magic"
primitive box = "@box"
primitive unbox = "@unbox"

@unsafe
let computeEscapedUSVLength = (usv: WasmI32, isString: Bool, topLevel: Bool) => {
  match (usv) {
    0x08n | 0x0Cn | 0x0An | 0x0Dn | 0x09n | 0x0Bn | 0x5Cn when !topLevel => 2n,
    0x27n when !isString && !topLevel => 2n,
    0x22n when isString && !topLevel => 2n,
    _ => usvEncodeLength(usv),
  }
}
@unsafe
let writeEscapedUSV = (
  usv: WasmI32,
  ptr: WasmI32,
  isString: Bool,
  topLevel: Bool,
) => {
  use WasmI32.{ (+), (==) }
  let mut ptr = ptr
  if (!topLevel) {
    if (computeEscapedUSVLength(usv, isString, topLevel) == 2n) {
      ptr += writeUtf8CodePoint(ptr, 0x5Cn) // \
    }
    ptr += writeUtf8CodePoint(ptr, match (usv) {
      0x08n => 0x62n, // \b,
      0x0Cn => 0x66n, // \f
      0x0An => 0x6En, // \n
      0x0Dn => 0x72n, // \r
      0x09n => 0x74n, // \t
      0x0Bn => 0x76n, // \v
      0x5Cn => 0x5Cn, // \\
      0x27n when !isString => 0x27n, // \'
      0x22n when isString => 0x22n, // \"
      _ => usv,
    })
  } else {
    ptr += writeUtf8CodePoint(ptr, usv)
  }
  ptr
}

@unsafe
let rec isCycleInStack = (
  value: GrainValue.HeapValue<a>,
  cycleStack: List<GrainValue.HeapValue<a>>,
) => {
  match (cycleStack) {
    [] => false,
    [stackValue, ..._] when stackValue is value => {
      true
    },
    [_, ...tail] => isCycleInStack(value, tail),
  }
}

@unsafe
let rec getCycleNumber = (
  value: GrainValue.HeapValue<a>,
  cycleMap: List<(GrainValue.HeapValue<a>, Number)>,
) => {
  match (cycleMap) {
    [] => -1n,
    [(head, num), ..._] when head is value => untagSimpleNumber(num),
    [_, ...tail] => getCycleNumber(value, tail),
  }
}

// Specific stringification functions for various data types
module Stringify {
  // Settings
  @unsafe
  let defaultRadix = 10n // The default radix for numbers
  abstract record StringifyState<a> {
    topLevel: Bool,
    cycleStack: List<GrainValue.HeapValue<a>>,
    cycleMap: Box<List<(GrainValue.HeapValue<a>, Number)>>,
  }
  provide let emptyState = () =>
    { topLevel: true, cycleStack: [], cycleMap: box([]) }

  // Heap Values
  @unsafe
  provide let string = (val: String, state) => {
    use WasmI32.{ (+), (-), (>) }
    let strPointer = WasmI32.fromGrain(val)
    let strLength = WasmI32.load(strPointer, _STR_LEN_OFFSET)
    // Compute String Length with Escaping
    let mut escapedLength = 0n
    let mut currentPtr = strPointer + _STR_DATA_OFFSET
    let mut remainingByteLength = strLength
    while (remainingByteLength > 0n) {
      let usv = Utf8.getCodePoint(currentPtr)
      let usvSize = Utf8.usvEncodeLength(usv)
      remainingByteLength -= usvSize
      currentPtr += usvSize
      escapedLength += computeEscapedUSVLength(usv, true, state.topLevel)
    }
    // Write String with Escaping
    let escapedStr = allocateString(escapedLength)
    let mut currentPtr = strPointer + _STR_DATA_OFFSET
    let mut escapedPtr = escapedStr + _STR_DATA_OFFSET
    let mut remainingByteLength = strLength
    while (remainingByteLength > 0n) {
      let usv = Utf8.getCodePoint(currentPtr)
      let usvSize = Utf8.usvEncodeLength(usv)
      remainingByteLength -= usvSize
      currentPtr += usvSize
      escapedPtr = writeEscapedUSV(usv, escapedPtr, true, state.topLevel)
    }
    let content = Doc.string(WasmI32.toGrain(escapedStr): String)
    ignore(val)
    if (state.topLevel) {
      content
    } else {
      Doc.doubleQuotes(content)
    }
  }
  @unsafe
  provide let bytes = (val: Bytes) => {
    use Doc.{ (++) }
    use WasmI32.{ (+), (-), (*), (<), (>) }
    let mut ptr = WasmI32.fromGrain(val)
    let len = WasmI32.load(ptr, _BYTES_LEN_OFFSET)
    let len = if (len > 32n) 32n else len // Limit to 32 bytes for display
    let ptr = ptr + _BYTES_DATA_OFFSET

    let hex = NumberUtils.get_HEX_DIGITS()
    let strLen = len * 3n - 1n // 2 hex digits + 1 space per byte - trailing space
    let str = allocateString(strLen)
    let strOffset = str + _STR_DATA_OFFSET
    Memory.fill(strOffset, 0x20n, strLen) // Fill with spaces
    for (let mut i = 0n; i < len; i += 1n) {
      let n = WasmI32.load8U(ptr, i) * 2n
      WasmI32.store16(strOffset, WasmI32.load16U(hex, n), i * 3n)
    }
    ignore(val)
    let content = Doc.string(WasmI32.toGrain(str): String)
    let content = if (len < 32n) content else content ++ Doc.string("...")
    Doc.angleBrackets(Doc.string("bytes: ") ++ content)
  }
  @unsafe
  provide let number = (val: Number) => {
    match (GrainValue.getNumberTag(val)) {
      GrainValue.SimpleNumberTag(v) =>
        Doc.string(NumberUtils.itoa32(untagSimpleNumber(v), defaultRadix)),
      GrainValue.Int64Tag(v) => {
        let num = GrainValue.getInt64Value(v)
        Doc.string(NumberUtils.itoa64(num, defaultRadix))
      },
      GrainValue.Float64Tag(v) => {
        let num = GrainValue.getFloat64Value(v)
        Doc.string(NumberUtils.dtoa(num))
      },
      GrainValue.RationalTag(v) => {
        use Doc.{ (++) }
        let ptr = WasmI32.fromGrain(v)
        let numerator = Bigint.bigIntToString(
          WasmI32.load(ptr, _RATIONAL_NUMERATOR_OFFSET),
          defaultRadix
        )
        let denominator = Bigint.bigIntToString(
          WasmI32.load(ptr, _RATIONAL_DENOMINATOR_OFFSET),
          defaultRadix
        )
        ignore(v)
        Doc.string(numerator) ++ Doc.string("/") ++ Doc.string(denominator)
      },
      GrainValue.BigIntTag(v) => {
        let ptr = WasmI32.fromGrain(v)
        let str = Bigint.bigIntToString(ptr, defaultRadix)
        ignore(v)
        Doc.string(str)
      },
      GrainValue.UnknownNumberTag => Doc.string("<unknown number>"),
    }
  }
  @unsafe
  provide let int32 = (val: Int32) => {
    let num = GrainValue.getInt32Value(val)
    Doc.string(NumberUtils.itoa32(num, defaultRadix))
  }
  @unsafe
  provide let float32 = (val: Float32) => {
    let num = GrainValue.getFloat32Value(val)
    let num = WasmF64.promoteF32(num)
    Doc.string(NumberUtils.dtoa(num))
  }
  @unsafe
  provide let uint32 = (val: Uint32) => {
    let num = GrainValue.getUint32Value(val)
    Doc.string(NumberUtils.utoa32(num, defaultRadix))
  }
  @unsafe
  provide let uint64 = (val: Uint64) => {
    let num = GrainValue.getUint64Value(val)
    Doc.string(NumberUtils.utoa64(num, defaultRadix))
  }
  // Short Values
  @unsafe
  provide let char = (val: Char, state) => {
    use WasmI32.{ (+) }
    let usv = untagChar(val)
    let strLength = computeEscapedUSVLength(usv, false, state.topLevel)
    let str = allocateString(strLength)
    writeEscapedUSV(usv, str + _STR_DATA_OFFSET, false, state.topLevel)
    ignore(val)
    let content = Doc.string(WasmI32.toGrain(str): String)
    if (state.topLevel) {
      content
    } else {
      Doc.singleQuotes(content)
    }
  }
  @unsafe
  provide let int8 = (val: Int8) =>
    Doc.string(NumberUtils.itoa32(untagInt8(val), defaultRadix))
  @unsafe
  provide let int16 = (val: Int16) =>
    Doc.string(NumberUtils.itoa32(untagInt16(val), defaultRadix))
  @unsafe
  provide let uint8 = (val: Uint8) =>
    Doc.string(NumberUtils.itoa32(untagUint8(val), defaultRadix))
  @unsafe
  provide let uint16 = (val: Uint16) =>
    Doc.string(NumberUtils.itoa32(untagUint16(val), defaultRadix))

  // Polymorphic conversions
  let shortValueToString = (val: GrainValue.ShortValue<a>, state) => {
    // Get The Short Tag
    match (GrainValue.getShortTag(val)) {
      CharTag(v) => char(v, state),
      Int8Tag(v) => int8(v),
      Int16Tag(v) => int16(v),
      Uint8Tag(v) => uint8(v),
      Uint16Tag(v) => uint16(v),
      UnknownShortTag => Doc.string("<unknown short value>"),
    }
  }

  // Constant Values
  @unsafe
  let constantValueToString = (val: GrainValue.ConstantValue<a>) => {
    use WasmI32.{ (==) }
    let v = WasmI32.fromGrain(val)
    if (v == WasmI32.fromGrain(true)) {
      Doc.string("true")
    } else if (v == WasmI32.fromGrain(false)) {
      Doc.string("false")
    } else if (v == WasmI32.fromGrain(void)) {
      Doc.string("void")
    } else {
      Doc.string("<unknown constant value>")
    }
  }
  @unsafe
  let rec heapValueToString = (val: GrainValue.HeapValue<a>, state) => {
    use Doc.{ (++) }
    use WasmI32.{ (!=) }
    // Check for Cycles
    if (isCycleInStack(val, state.cycleStack)) {
      let cycleMap = unbox(state.cycleMap)
      let cycleIndex = match (getCycleNumber(val, cycleMap)) {
        -1n => {
          use WasmI32.{ (+) }
          let index = match (cycleMap) {
            [] => 1n,
            [(_, n), ..._] => untagSimpleNumber(n) + 1n,
          }
          state.cycleMap := [(val, tagSimpleNumber(index)), ...cycleMap]
          index
        },
        n => n,
      }
      return Doc.string("<cycle to <")
        ++ Doc.string(NumberUtils.itoa32(cycleIndex, defaultRadix))
        ++ Doc.string(">>")
    }
    // Get The Heap Tag
    let content = match (GrainValue.getHeapTag(val)) {
      TupleTag(v) =>
        tuple(v, { ...state, cycleStack: [val, ...state.cycleStack] }),
      ArrayTag(v) =>
        array(v, { ...state, cycleStack: [val, ...state.cycleStack] }),
      RecordTag(v) =>
        _record(v, { ...state, cycleStack: [val, ...state.cycleStack] }),
      ADTTag(v) => adt(v, { ...state, cycleStack: [val, ...state.cycleStack] }),
      ClosureTag(_) => Doc.string("<lambda>"),
      StringTag(v) => string(v, state),
      BytesTag(v) => bytes(v),
      // Boxed Number Types
      BoxedNumberTag(v) => number(v),
      // Generic Number Types
      Int32Tag(v) => int32(v),
      Float32Tag(v) => float32(v),
      Uint32Tag(v) => uint32(v),
      Uint64Tag(v) => uint64(v),
      // Unknown
      GrainValue.UnknownTag => Doc.string("<unknown heap value>"),
    }
    let cycleIndex = getCycleNumber(val, unbox(state.cycleMap))
    return if (cycleIndex != -1n) {
      Doc.group(
        Doc.angleBrackets(
          Doc.string(NumberUtils.itoa32(cycleIndex, defaultRadix))
        )
          ++ Doc.blank(1)
          ++ content
      )
    } else {
      content
    }
  }
  and tupleHelp = (vals: List<GrainValue.StackTag<a>>, isVariant, state) => {
    let state = { ...state, topLevel: false }
    use Doc.{ (++) }
    let content = Doc.parens(
      Doc.indent(
        Doc.concatMap(
          lead=next => Doc._break,
          sep=(prev, next) => Doc.breakableSpace,
          trail=prev => Doc.empty,
          f=(final, val) => {
            let val = taggedValue(val, state)
            if (final) {
              Doc.group(val) ++ Doc.trailingComma
            } else {
              Doc.group(val ++ Doc.comma)
            }
          },
          vals
        )
      )
        ++ Doc._break
    )
    match (vals) {
      [_] when !isVariant => Doc.string("box") ++ content,
      _ => content,
    }
  }
  and tuple = (val: GrainValue.TupleValue<e>, state) => {
    let vals = GrainValue.getTupleData(val)
    tupleHelp(vals, false, state)
  }
  and array = (val: Array<a>, state) => {
    let state = { ...state, topLevel: false }
    use Doc.{ (++) }
    let vals = GrainValue.getArrayData(val)
    Doc.arrayBrackets(
      Doc.indent(
        Doc.concatMap(
          lead=next => Doc._break,
          sep=(prev, next) => Doc.breakableSpace,
          trail=prev => Doc.empty,
          f=(final, val) => {
            let val = taggedValue(val, state)
            if (final) {
              Doc.group(val) ++ Doc.trailingComma
            } else {
              Doc.group(val ++ Doc.comma)
            }
          },
          vals
        )
      )
        ++ Doc._break
    )
  }
  and _recordHelp = (vals: List<(String, GrainValue.StackTag<a>)>, state) => {
    use Doc.{ (++) }
    Doc.braces(
      Doc.indent(
        Doc.concatMap(
          lead=next => Doc.space ++ Doc._break,
          sep=(prev, next) => Doc.breakableSpace,
          trail=last => Doc.space,
          f=(final, (name, val)) => {
            let val = taggedValue(val, { ...state, topLevel: false })
            let entry = Doc.group(
              Doc.string(name) ++ Doc.string(":") ++ Doc.space ++ val
            )
            if (final) {
              entry ++ match (vals) {
                [_] => Doc.comma,
                _ => Doc.trailingComma,
              }
            } else {
              Doc.group(entry ++ Doc.comma)
            }
          },
          vals
        )
      )
        ++ Doc._break
    )
  }
  and _record = (val: GrainValue.RecordValue<a>, state) => {
    _recordHelp(GrainValue.getRecordData(val), state)
  }
  and list = (val: List<a>, state) => {
    use Doc.{ (++) }
    Doc.listBrackets(
      Doc.indent(
        Doc.concatMap(
          lead=next => Doc._break,
          sep=(prev, next) => Doc.breakableSpace,
          trail=prev => Doc.empty,
          f=(final, val) => {
            let value = value(val, { ...state, topLevel: false })
            if (final) {
              Doc.group(value) ++ Doc.trailingComma
            } else {
              Doc.group(value ++ Doc.comma)
            }
          },
          val
        )
      )
        ++ Doc._break
    )
  }
  and adt = (val: GrainValue.ADTValue<a>, state) => {
    use Doc.{ (++) }
    if (GrainValue.isListVariant(val)) {
      list(magic(val): List<b>, { ...state, topLevel: false })
    } else {
      let (name, variantData) = GrainValue.getVariantData(val)
      Doc.string(name) ++ match (variantData) {
        GrainValue.TupleVariant(vals) =>
          tupleHelp(vals, true, { ...state, topLevel: false }),
        GrainValue.RecordVariant(vals) =>
          _recordHelp(vals, { ...state, topLevel: false }),
        EmptyVariant => Doc.empty,
      }
    }
  }
  and taggedValue = (val: GrainValue.StackTag<a>, state) => {
    match (val) {
      HeapTag(v) => heapValueToString(v, state),
      ShortTag(v) => shortValueToString(v, state),
      NumberTag(v) => number(v),
      ConstantTag(v) => constantValueToString(v),
      UnknownTag => Doc.string("<unknown value>"),
    }
  }
  and value = (val: a, state) => taggedValue(GrainValue.getTag(val), state)

  provide { value }
}

provide let toString = (val: a) => {
  // Note: This is a bit of hack to get around grain's lack of forall types
  let val = magic(val): b
  let ast = Stringify.value(val, Stringify.emptyState())
  Doc.Engine.toString(LF, 80, ast)
}
